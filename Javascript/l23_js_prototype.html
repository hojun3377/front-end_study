<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Javascript prototype</title>
    <script src="./js/l23_js_prototype.js" defer></script>
  </head>
  <body>
    <h1>Javascript 프로토타입</h1>
    <article>
      <h2>function</h2>
      <ul>
        <li>함수형 언어인 자바스크립트는 프로토타입 언어로도 불린다.</li>
        <li>함수를 선언하면 프로토타입이 생성되고, 설계도 역할인 프로토타입은 서로 다른 프로토타입을 연결(__proto__)해서 상속을 대신한다.</li>
        <li>
          프로토타입에 대한 이해를 해야하는 이유
          <ul>
            <li>객체지향언어의 상속과 개념이 다르기 때문 js 고급에 오면 개념이 헷갈릴 수 있다.</li>
            <li>
              프로그래밍을 경험하지 못하는 사람들이 프로그래밍을 하기 위해 자바스크립트로 새로운 언어를 만들고 있기 때문에
              <br>프로토타입을 이해하면 자바스크립트로 만든 모든 언어를 이해할 수 있다.(바닐라 자바스크립트, 바닐라 코딩)
            </li>
            <li>
              프로토타입이 2차원적 개념이면 객체지향적 상속은 3차원적 개념이기 때문에 프로토타입 언어가 유행하고 있다.
              <br>암호화폐 -> 계산이 중요한 프로그래밍, 설계가 필요없다.
            </li>
          </ul>
        </li>
        <li>함수를 선언하면 prototype이 생성된다.</li>
        <li>
          함수를 선언하면 {} body 안을 this(멤버, 필드, 속성)이라한다.
          <br>이 멤버는 객체를 생성할 때 해당 객체의 prototype이 된다.
          <br>( 인스턴스 객체는 별개의 prototype을 가질 수 없다. )
        </li>
        <li>
          상속받지 않은 함수는 __proto__가 자기자신의 prototype이고, 이 prototype은 constructor가 상속받지 않은 함수를, __proto__는 Object.prototype을 가리키는 객체이다.
        </li>
        <li>Object.prototype이 모든 객체의 최상위 부모다.</li>
        <li>console창 확인</li>
      </ul>
    </article>
    <article>
      <h2>class</h2>
      <ul>
        <li>함수와 차이점이 있다면 class에 선언된 필드 중에 함수가 prototype에 선언된다.</li>
        <li>
          Object.create()는 객체를 생성하고 상속하는 원시적 방법으로 객체를 생성할 prototype을 공유(상속)하기 때문에(부모의 필드는 자식이 __proto__를 링크한다.) 필드에 선언된 함수를 상속받을 수 없다. 그러므로 멤버함수는 prototype에 선언해야한다.</li>
        <li>prototype은 정적( &lt;-&gt; 인스턴스 new )으로 언제든 참조 가능하기 때문에 객체 생성 없이 호출가능하다.</li>
        <li>class의 멤버함수는 function.prototype에 선언한 함수와 다르게 자신의 prototype을 갖지 않는다.</li>
      </ul>
    </article>
  </body>
</html>
